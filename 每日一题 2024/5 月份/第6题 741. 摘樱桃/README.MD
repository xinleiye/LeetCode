# 摘樱桃

给你一个 `n x n` 的网格 `grid` ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：

- `0` 表示这个格子是空的，所以你可以穿过它。
- `1` 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
- `-1` 表示这个格子里有荆棘，挡着你的路。

请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：

- 从位置 `(0, 0)` 出发，最后到达 `(n - 1, n - 1)` ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 `0` 或者 `1` 的格子）；
- 当到达 `(n - 1, n - 1)` 后，你要继续走，直到返回到 `(0, 0)` ，只能向上或向左走，并且只能穿越有效的格子；
- 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 `0` ）；
- 如果在 `(0, 0)` 和 `(n - 1, n - 1)` 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

**示例 1：**

![示例1](./eg1.jpeg)

``` javascript
输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]]
输出：5
解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。
在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。
然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。
总共捡到 5 个樱桃，这是最大可能值。
```

**示例 2：**

``` javascript
输入：grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
输出：0
```

**提示：**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 50`
- `grid[i][j]` 为 `-1`、`0` 或 `1`
- `grid[0][0] != -1`
- `grid[n - 1][n - 1] != -1`

**解答：**

**#**|**编程语言**|**时间（ms / %）**|**内存（MB / %）**|**代码**
--|--|--|--|--
1|javascript|72 / 100.00|55.98 / 57.14|[动态规划](./javascript/ac_v1.js)

来源：力扣（LeetCode）

链接：https://leetcode.cn/problems/cherry-pickup

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
